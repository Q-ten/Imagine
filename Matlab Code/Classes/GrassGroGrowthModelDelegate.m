% This is the implementation of a concrete GrassGroGrowthModelDelegate 
% based on the Abstract class.
%
% The GrassGroGrowthModel uses data generated by the GrassGro model. This
% growth model imports that monthly data and calculates income and costs
% based on nominal prices that are provided by the user in this model's setup dialog.
classdef GrassGroGrowthModelDelegate < GrowthModelDelegate
    
    % Properties from parent include 
    % state
    % gm - handle to the owning GrowthModel
    % stateSize
    % supportedImagineEvents

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    % These are the concrete implementations of the Abstract properties
    properties
        modelName = 'Imported GrassGro Data Model'; 
        
        % A list of strings with the names of the CropCategories that this
        % GrowthModel will be appropriate to model.
        supportedCategories = {'Pasture'};
                   
        % This will be a string cell array with descriptions of each
        % element of the state. Usually just one or two words - more labels
        % than descriptions.
        stateDescription = {};
       
    end
           
    properties
                
        % The ImagineEvents for this growth model. This is where the triggers will be stored, 
        % but the functions will also be defined in here.
        % You should define a function that returns the default list of
        % growthModelEvents. These should match the transitionFunctions
        % you've defined for each event.
       
        growthModelInitialEvents
        growthModelRegularEvents
        growthModelDestructionEvents
        growthModelFinancialEvents = ImagineEvent.empty(1, 0);
        
        % productPriceModels - a PriceModel for each product that can be
        % produced by this growthModel. The Units of the products are found
        % as the denominator of the PriceModels. 
        % When a product is produced, the Amount's unit can be used to work
        % out which price to use. It will match the denominator unit. (The
        % numerator will be in currency, probably $).
        productPriceModels
                
    end
    
    properties (Dependent)

        % growthModelOutputUnits - a list of Units that provide list of the
        % types of outputs the growthModel provides when passed the state
        % of a PlantedCrop. This list should include the union of all the
        % coreCropOutputUnits provided by the cropCategorys that this
        % growthModel supports.
        %
        % These will come from calling calculateOutputs with an argument. 
        growthModelOutputUnits
        
        % growthModelOutputRates - a list of 0 rates that provide the
        % rate units that come out of the calculateOuputs function.
        % The rates can be important if you need to know how the
        % denominator will come out.
        % There is a case where the denominator will be nothing or just
        % 'unit' when it doesn't make sense for the rate to be a rate, but
        % an amount. Eg, height of Wheat. Doesn't make sense to divide by
        % Hectares. Or even more starkly - colour of wheat. This is a
        % weird but possibly useful output, but would be silly for it to be a rate.
        %
        % These will come from calling calculateOutputs with an argument.
        growthModelOutputRates 
    end
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


    % These are the Simple Pasture model specific properties.
    properties (Access = public)
        
        % The GrassGroModel
        ggm       
        costs
        woolSales
        sheepSales
        spatialInteractions
    end
       
    
    methods (Static)
       
        function obj = loadobj(obj)

            % TODO
            if isstruct(obj)
                newObj = GrassGroGrowthModelDelegate();
                fns = fieldnames(obj);
                for i = 1:length(fns)
                    try
                       newObj.(fns{i}) = obj.(fns{i}); 
                    catch e
                    end
                end
            else                         
                fns = fieldnames(obj);
                ix = find(strcmp(fns, 'spatialInteractions'), 1, 'first');
                if ~isempty(ix)
                    gm = GrassGroGrowthModelDialog('setupParameters', obj.woolSales, obj.sheepSales, obj.costs, obj.ggm, obj.spatialInteractions);                                
                else
                    gm = GrassGroGrowthModelDialog('setupParameters', obj.woolSales, obj.sheepSales, obj.costs, obj.ggm);                            
                end
                gmFields = fieldnames(gm);
                for i = 1:length(gmFields)
                   obj.(gmFields{i}) = gm.(gmFields{i}); 
                end
                
                % Check for the Husbandry event.
                hasHusbandry = false;
                for i = 1:length(obj.growthModelRegularEvents)
                   if strcmp(obj.growthModelRegularEvents(i).name, 'Husbandry')
                        hasHusbandry = true;
                        break;
                   end
                end
                
                if (~hasHusbandry)
                   % Then we need to add it.
                   [~, ies, ~] = makeGrassGroPastureImagineEvents();
                   for i = 1:length(ies)
                      if strcmp(ies(i).name, 'Husbandry')
                          obj.growthModelRegularEvents(end + 1) = ies(i);
                          obj.growthModelRegularEvents(end).trigger = obj.getTriggerForEvent('Husbandry');
                          msgbox(['Loaded old GrassGroGrowthModelDelegate object and inserted Husbandry event.', ...
                              ' You need to set up the price for this event before simulating or you''ll get problems.'], 'Need to populate Husbandry price.')
                          break;
                      end
                   end
                end
            end
        end
        
    end
    
    methods
    
        % These methods are required from the Abstract parent class
        % GrowthModelDelegate.
        
        % This is the constructor for the concrete subclass. It should set
        % up all the parent's Abstract properties here, then go on to setup
        % any parameters specific to the concrete subclass.
        function gmDel = GrassGroGrowthModelDelegate(gm)
            if nargin > 0
                super_args = {gm};
            else
                super_args = {};
            end
            
            gmDel = gmDel@GrowthModelDelegate(super_args{:});
            
            % Now set up the specific default parameters for this growth model.
            
            % The priceModels, events and outputUnits need to be set up
            % here.
            [init, reg, dest] = makeGrassGroPastureImagineEvents;
            gmDel.growthModelInitialEvents = init;
            gmDel.growthModelRegularEvents = reg;
            gmDel.growthModelDestructionEvents = dest;
            
            gmDel.productPriceModels = makeGrassGroPastureProductPriceModels;
            
            % Make the rainfall based output units by calling the calculate
            % outputs function with an empty state and a third argument.
            gmDel.calculateOutputs([], 'rate');
            
            % Could set up the parameters here, but you could leave it
            % up to the GUI. It's probably better if they are defined in
            % one place.
            
        end
        
        % This function propagates the state over one month. This should be
        % set up as appropriate to the concrete subclass.
        % Need to return the state - not set it in plantedCrop as we have
        % to change the month day before we set the state.
        function [newState, productRates] = propagateState(gmd, plantedCrop, sim)
        
            productRates = Rate.empty(1, 0);
            
            % Return the potential products if plantedCrop and sim are
            % empty.
            if (isempty(sim) && isempty(plantedCrop))
                newState = [];
                return
            end
            
            newState = plantedCrop.state;

        end
        
        % This function is responsible for setting up all the parameters
        % particular to the concrete subclass. It will probably launch a
        % GUI which will be passed the GrowthModelDelegate and the GUI will
        % alter the pubilc parameters that are available to it when it is
        % saved.
        function gmDel = setupGrowthModel(gmDel, cropName)

            model.woolSales = gmDel.woolSales;
            model.sheepSales = gmDel.sheepSales;
            model.costs = gmDel.costs;
            model.ggm = gmDel.ggm;
            model.spatialInteractions = gmDel.spatialInteractions;
            
            output = GrassGroGrowthModelDialog(cropName, model);
            if ~isempty(output)
               gmDel.woolSales = output.woolSales;
               gmDel.sheepSales = output.sheepSales;
               gmDel.costs = output.costs;
               if isempty(gmDel.ggm)
                   gmDel.ggm = output.ggm;
               else
                   gmDel.ggm.copyFields(output.ggm);
               end
               if gmDel.ggm.isValid                  
                   gmDel.ggm.establishEventSwitches;
                   for i = 1:length(gmDel.growthModelRegularEvents)
                       gmDel.growthModelRegularEvents(i).trigger = gmDel.getTriggerForEvent(gmDel.growthModelRegularEvents(i).name); 
                   end
               end
               if ~isempty(output.spatialInteractions)
                   gmDel.spatialInteractions = output.spatialInteractions;
               end
            end
        end
        
        % This function renders a display of the growthModelDelegate's
        % parameters as a kind of summary. This is used in the crop wizard
        % and displays a summary of the saved growth model to be viewed
        % before and after the user enters the main GUI (launched via
        % setupGrowthModel above). This function should plot the summary on
        % ax, an axes object.
        function renderGrowthModel(gmDel, ax)
            picture = './Resources/SimplePasture.jpg';
            title = 'Imported Grass Gro Data Model';
            expo = {'The GrassGro Growth Model uses imported data from GrassGro.', ...
                    'The model parameters are used to determine the nominal ', ... 
                    'income and costs of the enterprise, which may then be varied', ...
                    'depending on the price models set up later.', ...
                    };
            try 
                im = imread(picture);
                im = im(end:-1:1,:,:);
            catch ME
                im = 0.3* ones(626, 417, 3);
            end

            axes(ax);
            cla
            image('CData', im);
            pos = [0 626 0 417];
            axis(pos);
            axis on
            hold on

           patch([0.05*pos(2) 0.05*pos(2) 0.95*pos(2) 0.95*pos(2)], [0.05*pos(4), 0.95*pos(4), 0.95*pos(4), 0.05*pos(4)], [0,0,0,0], 'k', 'FaceAlpha', 0.5);

           % Put it at 10%, 10%
            text(0.1*pos(2), 0.9*pos(4), title, 'Color', 1*[1,1,1], 'VerticalAlignment', 'top', 'FontSize', 16);
            text(0.1*pos(2), 0.8*pos(4), expo, 'Color', 1*[1,1,1], 'VerticalAlignment', 'top');
        end 
        
        % This function calculates the growthModel outputs based on the
        % state. Outputs are given in term of Rates in a similar fashion to
        % the products.
        % It throws an error if the units in the outputColumn don't match
        % the units provided by the growthModel.
        %
        % If state is empty and a third argument is supplied which is
        % 'unit' or 'rate' then calculateOutputs returns the units or rates
        % (with 0 as the number) that this function would return when it had a state.
        % If state is supplied along with the third argument, it is
        % ignored.
        % 
        % When the third argument is supplied, this function makes the output units for this growth model. These are the
        % units we want to keep track of as the crop grows, and which we might want
        % to apply costs to, but are not products.
        % For example biomass might be an output for plantation crops. Shoots,
        % leaves, height etc might be outputs for grasses. Soil moisture content
        % might also be an output.

        function outputsColumn = calculateOutputs(gmd, state, unitOrRate) %#ok<MANU>
            
            persistent numeratorUnits
            persistent denominatorUnits
            persistent outputRates
            
            % No outputs for now. We could end up putting all most of the
            % GrassGroModel into the state, but that would only slow things
            % down. For now I'll keep it empty.
            
            if isempty(numeratorUnits)
                numeratorUnits = Unit.empty(1, 0);
            end

            if isempty(denominatorUnits)
                denominatorUnits = Unit.empty(1, 0);
            end
                    
                        
            if isempty(state)                
                if nargin == 3
                    
                    if length(denominatorUnits) ~= length(numeratorUnits)
                        error('GrassGroGrowthModel needs the same number of numerator units as denominator units.');
                    end
                    
                    switch unitOrRate
                        
                        case 'unit'
                            outputsColumn = numeratorUnits;
                            
                        case 'rate'
                            if isempty(outputRates)
                                outputRates = Rate.empty(1, 0);
                                for i = 1:length(numeratorUnits)
                                    outputRates(i) = Rate(0, numeratorUnits(i), denominatorUnits(i));
                                end
                            end
                            outputsColumn = outputRates;
                    end
                    return
                end
                if isempty(numeratorUnits) && isempty(denominatorUnits)
                    outputRates = Rate.empty(1, 0);
                else                    
                    outputRates = Rate(0, numeratorUnits, denominatorUnits);
                end
                outputsColumn = outputRates;            
                return
            end
                        
            % The only output is the FOO, returned as FOO / Ha
 %           outputRates(1).number = state.FOO;
             outputRates = Rate.empty(1, 0);
             outputsColumn = outputRates;
            
        end
        
        % We get the growthModelOutputRates and Units from the
        % calculateOutputs function.
        function gMOUs = get.growthModelOutputUnits(gmDel)
            gMOUs = gmDel.calculateOutputs([], 'unit');
        end
        
        function gMORs = get.growthModelOutputRates(gmDel)
            gMORs = gmDel.calculateOutputs([], 'rate');
        end
        
        % As well as these core methods, you need to implement methods for
        % each supported ImagineEvent of the form
        %
        % outputProducts = transitonFunction_EVENTNAME(gmDel, ...)
        % where EVENTNAME happens to be the name of the event that is supported.
        %
        % outputProducts should actually be rates. As in 20 tonnes of
        % Biomass per Ha. The Ha Amount comes from the regime and the total
        % amount comes from the multiplication of the two.
        %
        % The transition functions should update the state within
        % plantedCrop.        
        % The Establishment transition function should initialise the state. 
        function [outputProducts, eventOutputs] = transitionFunction_Establishment(gmDel, plantedCrop, sim) 
            outputProducts = Rate.empty(1, 0);
            eventOutputs = Rate.empty(1, 0);
            
            % Return list of products and outputs if called with no
            % arguments.
            if(isempty(plantedCrop) && isempty(sim))
                outputProducts = Rate.empty(1, 0);
                return; 
            end                    

            sis = gmDel.spatialInteractions;

            if isempty(sis) || isempty(sim.currentSecondaryInstalledRegime)
                plantedCrop.state.NCZWidth = 0;
                return
            end

            % We don't have the
            % relevant months.
            % We make them up. We assume May to October.
            firstRM = 5;
            lastRM = 10;

            % For the growing season rainfall, we'll cheat and look ahead to get
            % it. Then we'll use the biomass at the start of the
            % year use that to set the competition for the year.
            firstMonth = (sim.year - 1) * 12 + firstRM;
            lastMonth = (sim.year - 1) * 12 + lastRM;
            gsr = sum(sim.monthlyRainfall(firstMonth:lastMonth));

            [compImpact, waterImpact] = getImpact(sis, gsr);

            if (~sis.useCompetition)
                compImpact = 0;
            end
            
            if (~sis.useWaterlogging)
                waterImpact = 0;
            end           
            
            % To calculate the spatial modifier, we'll ask the secondary
            % regime for a few outputs. We need the crop area and the 'Crop
            % Interface' length, which is basically how long the
            % competition zone is.

            % Once we have the biomass for a tree, we have the curve. Then
            % with the extent and the interface length we can work out the
            % area that's  affected. Then we need to ask the crop for it's
            % area. We work out the effective lost area as a percentage of
            % the total area. This is the spatial modifier.
            cropInterfaceUnit = Unit('', 'Crop Interface Length', 'm');

            % Also need the spacing within rows so we can calculate
            % competition costs fairly with different layouts.
            plantSpacing = sim.currentSecondaryInstalledRegime.getRegimeParameter('plantSpacing');
            if isempty(plantSpacing)
                error('Need to be able to access the regime''s plantSpacing parameter.');
            end

            % Get the crop interface from the secondary regime. If the
            % regime doesn't implement the crop interface output then we'll
            % assume that it's zero.
            cropInterface = Amount(0, cropInterfaceUnit); 
            if ~isempty(sim.currentSecondaryInstalledRegime)
                 if ~isempty(sim.currentSecondaryPlantedCrop)
                    cropInterface = sim.currentSecondaryInstalledRegime.getAmount(cropInterfaceUnit);
                 end
            end

            % Get raw spatial interactions bounds from sis:
            BGBMUnit = Unit('', 'Below-ground Biomass', 'Tonne');
            AGBMUnit = Unit('', 'Above-ground Biomass', 'Tonne');
            if~isempty(sim.currentSecondaryPlantedCrop)
                BGBM = sim.currentSecondaryPlantedCrop.getAmount(BGBMUnit);
                AGBM = sim.currentSecondaryPlantedCrop.getAmount(AGBMUnit);
                if isempty(BGBM)
                    BGBM = Amount(0, BGBMUnit);
                    AGBM = Amount(0, AGBMUnit);
                end
            else
                BGBM = Amount(0, BGBMUnit);
                AGBM = Amount(0, AGBMUnit);
            end
            [compExtent, compYieldLoss, waterExtent, waterYieldGain] = sis.getRawSIBounds(AGBM.number * 1000, BGBM.number * 1000, plantSpacing);

            NCZWidth = 0;

            % Scale percentage numbers to [0, 1]
            compYieldLoss = compYieldLoss / 100;
            waterYieldGain = waterYieldGain / 100;

            csir = sim.currentSecondaryInstalledRegime;
            exclusionZoneWidth = 0;
            if ~isempty(csir)
                regObj = csir.regimeObject;  
                exclusionZoneWidth = regObj.getExclusionZoneWidth;
            end

                                % modify bounds based on the NCZ
            if compExtent > (NCZWidth + exclusionZoneWidth) && compExtent > 0
                compYieldLoss = compYieldLoss * (compExtent - NCZWidth - exclusionZoneWidth) / compExtent;
                compExtent = compExtent - NCZWidth - exclusionZoneWidth;
            else
               compExtent = 0; 
               compYieldLoss = 0;
            end

            if waterExtent > (NCZWidth + exclusionZoneWidth) && waterExtent > 0
                waterYieldGain = waterYieldGain * (waterExtent - NCZWidth - exclusionZoneWidth) / waterExtent;
                waterExtent = waterExtent - NCZWidth - exclusionZoneWidth;
            else
                waterExtent = 0; 
                waterYieldGain = 0;
            end                    

            affectedExtent = 0;
            if compExtent > affectedExtent
                affectedExtent = compExtent;
            end
            if waterExtent > affectedExtent
                affectedExtent = waterExtent;
            end

            % Must have +ve area.
            if affectedExtent > 0 && ~isempty(cropInterface)

            %    affectedAreaHa = cropInterface.number * affectedExtent / 10000;

                areaOfSIWaterCurve = waterYieldGain * waterImpact * waterExtent / 2;
                areaOfSICompCurve = compYieldLoss * compImpact * compExtent / 2;

                % Ok up to here, Not sure about the next line

                areaOfSICompAbove100 = 0;
                if compYieldLoss * compImpact > 1
                   ext = compExtent * (compYieldLoss * compImpact - 1) / (compYieldLoss * compImpact); 
                   areaOfSICompAbove100 = (compYieldLoss * compImpact - 1) * ext / 2;
                end

                % Get rid of the bit above 100%.
                areaOfSICompCurve = areaOfSICompCurve - areaOfSICompAbove100;

                % Get the total loss by subtracting the gain.
                totalLossUnderCurve = areaOfSICompCurve - areaOfSIWaterCurve;

                % The area under the curve becomes our equivalent
                % NCZ.
                if (totalLossUnderCurve > 0)
                    NCZWidth = totalLossUnderCurve;
                end

            end

            if NCZWidth < 0
                NCZWidth = 0;
            end

            plantedCrop.state.NCZWidth = NCZWidth;
            
        end
        
        function [outputProducts, eventOutputs] = transitionFunction_Shearing(gmDel, plantedCrop, sim) 

            % outputProducts are wool. In this GM we actually output a 
            % homogenised $/DSE based on the structure of the flock and
            % the nominal prices and amounts expected from the different 
            % components
            unit = Unit('', 'Nominal Wool Income', 'Nominal Dollar');
            unit2 = Unit('', 'Nominal Shearing Costs', 'Nominal Dollar');
            denominatorUnit = Unit('', 'Paddock', 'Unit');
            
            % Return list of products and outputs if called with no
            % arguments.
            if(isempty(plantedCrop) && isempty(sim))
                outputProducts = Rate(0, unit, denominatorUnit);
                eventOutputs = Rate(0, unit2, denominatorUnit);
                return; 
            end
            
            attribution = gmDel.ggm.getYearlyAttributionForPaddock(sim.year, gmDel.ggm.paddockNumber);
            areaUnit = Unit('', 'Area', 'Hectare');
            paddockSizeMultiplier = plantedCrop.getAmount(areaUnit).number / gmDel.ggm.paddockSize;            
            

            
            sheepNumbers = gmDel.ggm.getSheepNumbers(sim.monthIndex);
            totalWoolByClass = gmDel.ggm.getWoolSold(sim.monthIndex) .* sheepNumbers;
            
            woolPrices = [...
                   gmDel.woolSales.ewes.woolPricePerKg, ...
                   gmDel.woolSales.eweHoggets.woolPricePerKg, ...
                   gmDel.woolSales.eweLambs.woolPricePerKg, ...
                   gmDel.woolSales.wethers.woolPricePerKg, ...
                   gmDel.woolSales.wetherHoggets.woolPricePerKg, ...
                   gmDel.woolSales.wetherLambs.woolPricePerKg];
            woolIncome = sum(woolPrices .* totalWoolByClass) * attribution * paddockSizeMultiplier;
            
            outputProducts = Rate(woolIncome, unit, denominatorUnit);
            
            % Use eventOutputs to define the costs.
            shearingCostsPerHead = [...
                   gmDel.costs.ewes.shearing, ...
                   gmDel.costs.eweHoggets.shearing, ...
                   gmDel.costs.eweLambs.shearing, ...
                   gmDel.costs.wethers.shearing, ...
                   gmDel.costs.wetherHoggets.shearing, ...
                   gmDel.costs.wetherLambs.shearing];
            
            finalWoolCosts = sum(shearingCostsPerHead .* sheepNumbers) * attribution * paddockSizeMultiplier;
            eventOutputs = Rate(finalWoolCosts, unit2, denominatorUnit);
            
        end
        
        function [outputProducts, eventOutputs] = transitionFunction_Husbandry(gmDel, plantedCrop, sim) 

            % No output products. Just care about the cost.
            % We put the nominal cost into the eventOutputs.

            unit = Unit('', 'Nominal Husbandry Costs', 'Nominal Dollar');
            denominatorUnit = Unit('', 'Paddock', 'Unit');
            
            % Return list of products and outputs if called with no
            % arguments.
            outputProducts = Rate.empty(1, 0);
            if(isempty(plantedCrop) && isempty(sim))
                eventOutputs = Rate(0, unit, denominatorUnit);
                return; 
            end
            
            attribution = gmDel.ggm.getYearlyAttributionForPaddock(sim.year, gmDel.ggm.paddockNumber);
            areaUnit = Unit('', 'Area', 'Hectare');
            paddockSizeMultiplier = plantedCrop.getAmount(areaUnit).number / gmDel.ggm.paddockSize;            
                        
            sheepNumbers = gmDel.ggm.getSheepNumbers(sim.monthIndex);
            
            % Use eventOutputs to define the costs.
            husbandryCostsPerHead = [...
                   gmDel.costs.ewes.maintenance, ...
                   gmDel.costs.eweHoggets.maintenance, ...
                   gmDel.costs.eweLambs.maintenance, ...
                   gmDel.costs.wethers.maintenance, ...
                   gmDel.costs.wetherHoggets.maintenance, ...
                   gmDel.costs.wetherLambs.maintenance];
            
            finalWoolCosts = sum(husbandryCostsPerHead .* sheepNumbers) * attribution * paddockSizeMultiplier;
            eventOutputs = Rate(finalWoolCosts, unit, denominatorUnit);
            
        end
        
        % Feeding occurs during the feedgap.
        % Output tonnes of feed per DSE.
        function [outputProducts, eventOutputs] = transitionFunction_Supplementary_Feeding(gmDel, plantedCrop, sim) 

            % No products.
            % EventOutputs are used to define the total nominal fodder
            % costs.
            unit = Unit('', 'Nominal Supplementary Feeding Cost', 'Nominal Dollar');
            denominatorUnit = Unit('', 'Paddock', 'Unit');
            outputProducts = Rate.empty(1, 0);
            
            % Return list of products and outputs if called with no
            % arguments.
            if(isempty(plantedCrop) && isempty(sim))
                outputProducts = Rate.empty(1, 0);
                eventOutputs = Rate(0, unit, denominatorUnit);
                return; 
            end 
            
            attribution = gmDel.ggm.getYearlyAttributionForPaddock(sim.year, gmDel.ggm.paddockNumber);
            areaUnit = Unit('', 'Area', 'Hectare');
            paddockSizeMultiplier = plantedCrop.getAmount(areaUnit).number / gmDel.ggm.paddockSize;

          
 
            finalFodderCost = gmDel.ggm.getFodderCost(sim.monthIndex) * attribution * paddockSizeMultiplier;
            eventOutputs = Rate(finalFodderCost, unit, denominatorUnit);
                                    
        end        
        
        function [outputProducts, eventOutputs] = transitionFunction_Sheep_Sales(gmDel, plantedCrop, sim) 
            
            unit = Unit('', 'Nominal Meat Income', 'Nominal Dollar');
            unit2 = Unit('', 'Nominal Sheep Sales Commission Cost', 'Nominal Dollar');
            denominatorUnit = Unit('', 'Paddock', 'Unit');
            
            % Return list of products and outputs if called with no
            % arguments.
            if(isempty(plantedCrop) && isempty(sim))
                outputProducts = Rate(0, unit, denominatorUnit);
                eventOutputs = Rate(0, unit2, denominatorUnit);
                return; 
            end
            
            attribution = gmDel.ggm.getYearlyAttributionForPaddock(sim.year, gmDel.ggm.paddockNumber);
            areaUnit = Unit('', 'Area', 'Hectare');
            paddockSizeMultiplier = plantedCrop.getAmount(areaUnit).number / gmDel.ggm.paddockSize;

            totalSheepSoldByClass = gmDel.ggm.getSheepSold(sim.monthIndex);

            sheepPrices = [...
                   gmDel.sheepSales.CFAEwes.pricePerHdCS2, gmDel.sheepSales.CFAEwes.pricePerHdCS3; ...
                   gmDel.sheepSales.eweHoggets.pricePerHdCS2, gmDel.sheepSales.eweHoggets.pricePerHdCS3; ...
                   gmDel.sheepSales.eweLambs.pricePerHdCS2, gmDel.sheepSales.eweLambs.pricePerHdCS3;...
                   gmDel.sheepSales.CFAWethers.pricePerHdCS2, gmDel.sheepSales.CFAWethers.pricePerHdCS3; ...
                   gmDel.sheepSales.wetherHoggets.pricePerHdCS2, gmDel.sheepSales.wetherHoggets.pricePerHdCS3; ...
                   gmDel.sheepSales.wetherLambs.pricePerHdCS2, gmDel.sheepSales.wetherLambs.pricePerHdCS3];

            sheepIncomeByClass = sheepPrices' .* totalSheepSoldByClass;
            
            finalSheepIncome = sum(sum(sheepIncomeByClass)) * attribution * paddockSizeMultiplier;
            outputProducts = Rate(finalSheepIncome, unit, denominatorUnit);
            
            finalSheepCosts = finalSheepIncome * gmDel.sheepSales.salesCommission / 100;
            eventOutputs = Rate(finalSheepCosts, unit2, denominatorUnit);
                 
        end
        
        function [outputProducts, eventOutputs] = transitionFunction_Sheep_Purchases(gmDel, plantedCrop, sim) 
            
            unit = Unit('', 'Nominal Sheep Purchases Cost', 'Nominal Dollar');
            denominatorUnit = Unit('', 'Paddock', 'Unit');
            outputProducts = Rate.empty(1,0);
            
            % Return list of products and outputs if called with no
            % arguments.
            if(isempty(plantedCrop) && isempty(sim))
                eventOutputs = Rate(0, unit, denominatorUnit);
                return; 
            end
            
            attribution = gmDel.ggm.getYearlyAttributionForPaddock(sim.year, gmDel.ggm.paddockNumber);
            areaUnit = Unit('', 'Area', 'Hectare');
            paddockSizeMultiplier = plantedCrop.getAmount(areaUnit).number / gmDel.ggm.paddockSize;

            totalSheepPurchasedByClass = gmDel.ggm.getSheepPurchased(sim.monthIndex);
            sheepPrices = [...
                   gmDel.sheepSales.CFAEwes.pricePerHdCS2, gmDel.sheepSales.CFAEwes.pricePerHdCS3; ...
                   gmDel.sheepSales.eweHoggets.pricePerHdCS2, gmDel.sheepSales.eweHoggets.pricePerHdCS3; ...
                   gmDel.sheepSales.eweLambs.pricePerHdCS2, gmDel.sheepSales.eweLambs.pricePerHdCS3;...
                   gmDel.sheepSales.CFAWethers.pricePerHdCS2, gmDel.sheepSales.CFAWethers.pricePerHdCS3; ...
                   gmDel.sheepSales.wetherHoggets.pricePerHdCS2, gmDel.sheepSales.wetherHoggets.pricePerHdCS3; ...
                   gmDel.sheepSales.wetherLambs.pricePerHdCS2, gmDel.sheepSales.wetherLambs.pricePerHdCS3];
            sheepPrices = mean(sheepPrices, 2);
                        
            totalSheepPurchases = sum(sheepPrices .* reshape(totalSheepPurchasedByClass, 6, 1)) * attribution * paddockSizeMultiplier;
            eventOutputs = Rate(totalSheepPurchases, unit, denominatorUnit);
                             
        end

        
        % Destruction doesn't do anything but we implement the function
        % so that the framework works.
        function [outputProducts, eventOutputs] = transitionFunction_Destruction(gmDel, plantedCrop, sim) %#ok<MANU>
            
            outputProducts = Rate.empty(1, 0);
            eventOutputs = Rate.empty(1, 0);
            
            eoDenominatorUnit1 = Unit();
            eoNumeratorUnit1 = Unit('', 'NCZ Width', 'm');
            eoNumeratorUnit2 = Unit('', 'NCZ Area', 'Hectare');
            eoNumeratorUnit3 = Unit('', 'Belt Opportunity Cost', 'Dollar');

            if(isempty(plantedCrop) && isempty(sim))
                eventOutputs = Rate(0, eoNumeratorUnit1, eoDenominatorUnit1);                
                eventOutputs(2) = Rate(0, eoNumeratorUnit2, eoDenominatorUnit1);
                eventOutputs(3) = Rate(0, eoNumeratorUnit3, eoDenominatorUnit1);
                return; 
            end
                        
            NCZWidth = plantedCrop.state.NCZWidth;
            NCZArea = 0;
            
            cropInterfaceUnit = Unit('', 'Crop Interface Length', 'm');
            cropInterface = Amount(0, cropInterfaceUnit); 
            if ~isempty(sim.currentSecondaryInstalledRegime)
                 if ~isempty(sim.currentSecondaryPlantedCrop)
                    cropInterface = sim.currentSecondaryInstalledRegime.getAmount(cropInterfaceUnit);
                 end
            end
            if ~isempty(cropInterface)
                NCZArea = cropInterface.number * plantedCrop.state.NCZWidth / 10000;
            end
            
            eventOutputs = Rate(NCZWidth, eoNumeratorUnit1, eoDenominatorUnit1);
            eventOutputs(2) = Rate(NCZArea, eoNumeratorUnit2, eoDenominatorUnit1);

            % Now calculate the opportunity cost. We need the income and
            % cost up until now. 
            profitsSoFar = plantedCrop.profit(plantedCrop.plantedMonth, sim.monthIndex, true);
            profitSoFar = sum(profitsSoFar);

            % Get the occurrences that will occur in just a moment after
            % the destruction event has been processed. This is a bit of a
            % hack, but I can't see any other way of doing it without major
            % disruption. calling processEvents with a second argument set
            % to true causes the events not to be processed 'officially',
            % but rather the occurrences are returned as an array. The crop
            % is not affected.
            ocs = plantedCrop.processEvents(sim, true);
            
            for i = 1:length(ocs)
                profitSoFar = profitSoFar + ocs(i).eventProfit.number;
            end            
            
            % Try to get the price for this event.
            eventCostPrice = sim.getCostPrice(plantedCrop.cropObject.name, 'Destruction');
            
            if (eventCostPrice.denominatorUnit == eoNumeratorUnit3)
               error(['Attempt made to calculate GrassGro crop Destruction cost in terms of opportunity cost of belts. That doesn''t make sense.', ...
                     ' Sorry it shows up in the list, but there was no other feasible way to get opportunity cost of belts without doing this.', ...
                     ' Please just make sure you don''t use the Belt Opportunity Cost as the unit in terms of which to calculate the Destruction cost.']); 
            end
            
            regimeAreaUnit = Unit('', 'Area', 'Hectare');
            primaryArea = sim.currentPrimaryInstalledRegime.getAmount(regimeAreaUnit).number;
            if (isempty(sim.currentSecondaryInstalledRegime))
                secondaryArea = 0;
            else
                secondaryArea = sim.currentSecondaryInstalledRegime.getAmount(regimeAreaUnit).number;
            end
                        
            % Use the costItem class to do all the calculations for us.
            % Just give it the eventOutputs we've worked out so far.
            thisEventCostItem = CostItem('Destruction', plantedCrop, sim, eventOutputs, outputProducts);
            
            profitSoFar = profitSoFar - thisEventCostItem.cost.number;
            
            % Ok, no we can work out the non-belt profit per hectare.
            % Check that primaryArea + NCZ + secondaryArea = 100. I think
            % we reduce the primary area by the ncz area.
            profitPerHectare = profitSoFar / (primaryArea);
            
            opportunityCost = (NCZArea + secondaryArea) * profitPerHectare;
            
            eventOutputs(3) = Rate(opportunityCost, eoNumeratorUnit3, eoDenominatorUnit1);                
        end
       
        
    end
    
    % Validation Methods
    methods
        
        % Checks that the class is right and things aren't empty
        function valid = gmdIsValid(gmd)
            valid = isa(gmd, 'GrassGroGrowthModelDelegate');
        end
        
        % Checks that the parameters are consistent and ready to go!
        % Note, this should really check quite a bit more. At least that
        % all the fields exist and are of the correct type.
        function ready = gmdIsReady(gmd)
            ready = gmdIsValid(gmd);
            if ~ready || ...
                isempty(gmd.costs) || isempty(gmd.woolSales) || isempty(gmd.sheepSales) ...
                || isempty(gmd.ggm)
                ready = 0;
                return
            end
            ready = 1;
            return
            if ~gmd.ggm.isValid
                ready = 0;
                return
            end
        end
        
        
        function cropNameHasChanged(gmd, previousName, newName)
              % No references to other crop names in the ABGompertz
              % growthmodel.
              % Note that we might need to update the event triggers one
              % day.
        end 
        
    end
   
    methods
        function trigger = getTriggerForEvent(gmDel, eventName)

            switch eventName

                case 'Establishment'
                    % Establishment is based on the regime
                    trigger = Trigger();

                case 'Supplementary Feeding'
                    trigger = gmDel.ggm.getTriggerForEvent(eventName);
                    
                case 'Shearing'
                    trigger = gmDel.ggm.getTriggerForEvent(eventName);

                case 'Husbandry'
                    trigger = gmDel.ggm.getTriggerForEvent(eventName);

                case 'Sheep Sales'
                    trigger = gmDel.ggm.getTriggerForEvent(eventName);
    
                case 'Sheep Purchases'
                    trigger = gmDel.ggm.getTriggerForEvent(eventName);

                case 'Destruction'
                    % Destruction is based on the regime.
                    trigger = Trigger();
                otherwise
                    error('SimplePastureGrowthModelDelegate: Tried to get trigger for unknown event.');
            end
        end        
    end
    
end


% This function makes the triggers for the GrassGro Pasture events.
% The cost price models are provided with a default denominatorUnit.
% Note that the denominatorUnit must match the growthModelOutput units 
% or the regimeOutputUnits for the cropCategory this growthModel is made
% for.
function [initialEvents, regularEvents, destructionEvents] =  makeGrassGroPastureImagineEvents()

    % All units for the prices will be in dollars.
    unit = Unit('', 'Money', 'Dollar');
    status = ImagineEventStatus('core', true, true, true, false, true);

    % Set up the planting event
    % Price is 'per Hectare'
    denominatorUnit = Unit('', 'Area', 'Hectare');
    costPriceModel = PriceModel('Establishment', unit, denominatorUnit, true);

    initialEvents  = ImagineEvent('Establishment', status, costPriceModel);
 
    % Regular events are 'Shearing', 'Sheep Sales'.
    status = ImagineEventStatus('core', true, false, true, false, true);

    % Price is 'per nominal shearing cost'
%    denominatorUnit = Unit('', 'Nominal Shearing Cost', 'Hectare');
    denominatorUnit = Unit('', 'Money', 'Nominal Dollar');

    costPriceModel = PriceModel('Shearing', unit, denominatorUnit, true);
    regularEvents(1)  = ImagineEvent('Shearing', status, costPriceModel);

    costPriceModel = PriceModel('Husbandry', unit, denominatorUnit, true);
    regularEvents(2)  = ImagineEvent('Husbandry', status, costPriceModel);    
    
    costPriceModel = PriceModel('Sheep Sales', unit, denominatorUnit, true);    
    regularEvents(3) = ImagineEvent('Sheep Sales', status, costPriceModel);

    costPriceModel = PriceModel('Sheep Purchases', unit, denominatorUnit, true);
    regularEvents(4) = ImagineEvent('Sheep Purchases', status, costPriceModel);

    
    % Feeding Event
     denominatorUnit = Unit('', 'Money', 'Nominal Dollar');
     costPriceModel = PriceModel('Supplementary Feeding', unit, denominatorUnit, true);
     regularEvents(5) = ImagineEvent('Supplementary Feeding', status, costPriceModel);
            
    
    % Only a token destruction event
    status = ImagineEventStatus('core', true, true, true, false, true);
    denominatorUnit = Unit('', 'Area', 'Hectare');
    costPriceModel = PriceModel('Destruction', unit, denominatorUnit, true);
    destructionEvents = ImagineEvent('Destruction', status, costPriceModel);

end

% This function makes the productPriceModels. 
% It defines what the products are. The denominator units used define the 
% units of the product. These are not changed later. Therefore care must be
% taken to ensure that the denominator units here match the numerator units
% in the rate returned by a transition function.
function pPMs = makeGrassGroPastureProductPriceModels


    % All units for the prices will be in dollars.
    unit = Unit('', 'Money', 'Dollar');

%    denominatorUnit = Unit('', 'Wool', 'Kg');
    denominatorUnit = Unit('', 'Nominal Wool Income', 'Nominal Dollar');
    pPMs = PriceModel('Wool Income', unit, denominatorUnit);

%    denominatorUnit = Unit('', 'DSE', 'Unit');    
    denominatorUnit = Unit('', 'Nominal Meat Income', 'Nominal Dollar');
    pPMs(2) = PriceModel('Sheep Sales Income', unit, denominatorUnit);

end

